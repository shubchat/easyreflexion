{"task_id": "HumanEval/0", "completion": "from typing import List, Optional\n\ndef has_close_elements(numbers: Optional[List[float]], threshold: Optional[float]) -> bool:\n    if numbers is None or threshold is None:\n        raise TypeError(\"Both numbers and threshold must be provided\")\n\n    def check_threshold(num1: float, num2: float, threshold: float) -> bool:\n        return abs(num1 - num2) < threshold\n\n    def compare_pairs(numbers: List[float], threshold: float) -> bool:\n        numbers.sort()\n        for i in range(len(numbers) - 1):\n            if check_threshold(numbers[i], numbers[i + 1], threshold):\n                return True\n        return False\n\n    return compare_pairs(numbers, threshold)", "result": "passed", "passed": true}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    def remove_spaces(s: str) -> str:\n        return s.replace(\" \", \"\")\n    \n    def is_balanced(s: str) -> bool:\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n    \n    def extract_groups(s: str) -> List[str]:\n        groups = []\n        start = 0\n        count = 0\n        for i, char in enumerate(s):\n            if char == '(':\n                if count == 0:\n                    start = i\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count == 0:\n                    groups.append(s[start:i+1])\n        return groups\n    \n    cleaned_string = remove_spaces(paren_string)\n    if not is_balanced(cleaned_string):\n        return []\n    \n    return extract_groups(cleaned_string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than the given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \"\"\"\n    if not isinstance(number, (float, int)):\n        raise TypeError(\"Input must be a float or integer.\")\n    \n    if number < 0:\n        raise ValueError(\"Input must be a non-negative number.\")\n    \n    integer_part = int(number)\n    decimal_part = number - integer_part\n    \n    return decimal_part", "result": "passed", "passed": true}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    def calculate_balance(operations: List[int]) -> int:\n        balance = 0\n        for operation in operations:\n            balance += operation\n            if balance < 0:\n                return True\n        return False\n\n    return calculate_balance(operations)", "result": "passed", "passed": true}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    return sum(numbers) / len(numbers) if numbers else 0.0\n\ndef calculate_absolute_deviations(numbers: List[float], mean: float) -> List[float]:\n    return [abs(number - mean) for number in numbers]\n\ndef calculate_mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = calculate_mean(numbers)\n    absolute_deviations = calculate_absolute_deviations(numbers, mean)\n    return sum(absolute_deviations) / len(absolute_deviations) if absolute_deviations else 0.0\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    return calculate_mean_absolute_deviation(numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    if not isinstance(numbers, list) or not all(isinstance(n, int) for n in numbers):\n        raise TypeError(\"numbers must be a list of integers\")\n    if not isinstance(delimiter, int):\n        raise TypeError(\"delimiter must be an integer\")\n    \n    def insert_delimiter(numbers: List[int], delimiter: int) -> List[int]:\n        result = []\n        for i in range(len(numbers) - 1):\n            result.append(numbers[i])\n            result.append(delimiter)\n        if numbers:\n            result.append(numbers[-1])\n        return result\n\n    return insert_delimiter(numbers, delimiter)", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(paren_group: str) -> int:\n        depth = 0\n        max_depth = 0\n        for char in paren_group:\n            if char == '(':\n                depth += 1\n                if depth > max_depth:\n                    max_depth = depth\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    def split_groups(paren_string: str) -> List[str]:\n        groups = []\n        current_group = \"\"\n        depth = 0\n        for char in paren_string:\n            if char == '(':\n                if depth == 0 and current_group.strip():\n                    groups.append(current_group.strip())\n                    current_group = \"\"\n                depth += 1\n            elif char == ')':\n                depth -= 1\n            current_group += char\n            if depth == 0 and current_group.strip():\n                groups.append(current_group.strip())\n                current_group = \"\"\n        if current_group.strip():\n            groups.append(current_group.strip())\n        return groups\n\n    groups = split_groups(paren_string)\n    return [max_depth(group) for group in groups if group]\n\n# Example usage:\n# print(parse_nested_parens('(()()) ((())) () ((())()())'))  # Expected: [2, 3, 1, 3]", "result": "passed", "passed": true}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef contains_substring(s: str, substring: str) -> bool:\n    return substring in s\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"The first argument must be a list of strings.\")\n    if not isinstance(substring, str):\n        raise TypeError(\"The second argument must be a string.\")\n    return [s for s in strings if contains_substring(s, substring)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    def calculate_sum(numbers: List[int]) -> int:\n        return sum(numbers)\n    \n    def calculate_product(numbers: List[int]) -> int:\n        product = 1\n        for number in numbers:\n            product *= number\n        return product\n    \n    total_sum = calculate_sum(numbers)\n    total_product = calculate_product(numbers) if numbers else 1\n    \n    return total_sum, total_product", "result": "passed", "passed": true}
{"task_id": "HumanEval/9", "completion": "from typing import List, Union\n\ndef rolling_max(numbers: List[Union[int, float]]) -> List[Union[int, float]]:\n    if not all(isinstance(number, (int, float)) for number in numbers):\n        raise ValueError(\"All elements in the input list must be integers or floats.\")\n    \n    max_so_far = float('-inf')\n    result = []\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\ndef longest_palindromic_suffix(string: str) -> str:\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string[i:]\n    return \"\"\n\ndef make_palindrome(string: str) -> str:\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n    if not string:\n        return \"\"\n    suffix = longest_palindromic_suffix(string)\n    prefix = string[:len(string) - len(suffix)]\n    return string + prefix[::-1]\n\n# Test cases\nif __name__ == \"__main__\":\n    print(make_palindrome(''))  # ''\n    print(make_palindrome('cat'))  # 'catac'\n    print(make_palindrome('cata'))  # 'catac'\n    print(make_palindrome('a'))  # 'a'\n    print(make_palindrome('aa'))  # 'aa'\n    print(make_palindrome('ab'))  # 'aba'\n    print(make_palindrome('race'))  # 'racecar'\n    print(make_palindrome('madam'))  # 'madam'\n    print(make_palindrome('abcba'))  # 'abcba'\n    print(make_palindrome('aabb'))  # 'aabbaa'\n    print(make_palindrome('abca'))  # 'abcba'\n    print(make_palindrome('abcdef'))  # 'abcdeffedcba'\n    try:\n        print(make_palindrome(None))  # Error\n    except ValueError as e:\n        print(e)  # \"Input must be a string\"\n    try:\n        print(make_palindrome(123))  # Error\n    except ValueError as e:\n        print(e)  # \"Input must be a string\"\n    print(make_palindrome('A man, a plan, a canal, Panama'))  # 'A man, a plan, a canal, Panama,amanaP ,lanac a ,nalp a ,nam A'\n    print(make_palindrome(' '))  # ' '\n    print(make_palindrome('abba'))  # 'abba'", "result": "passed", "passed": true}
{"task_id": "HumanEval/11", "completion": "def xor_char(c1: str, c2: str) -> str:\n    return '1' if c1 != c2 else '0'\n\ndef string_xor(a: str, b: str) -> str:\n    if a is None or b is None:\n        return None\n    if len(a) != len(b):\n        return None\n    if not all(c in '01' for c in a + b):\n        return None\n    return ''.join(xor_char(c1, c2) for c1, c2 in zip(a, b))", "result": "passed", "passed": true}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[Optional[str]]) -> Optional[str]:\n    valid_strings = [s for s in strings if s is not None]\n    if not valid_strings:\n        return None\n    return max(valid_strings, key=lambda s: (len(s), valid_strings.index(s)))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    def gcd(x: int, y: int) -> int:\n        while y != 0:\n            x, y = y, x % y\n        return abs(x)\n    \n    return gcd(a, b)\n\n# Test cases\nprint(greatest_common_divisor(3, 5))       # Expected output: 1\nprint(greatest_common_divisor(25, 15))     # Expected output: 5\nprint(greatest_common_divisor(0, 5))       # Expected output: 5\nprint(greatest_common_divisor(5, 0))       # Expected output: 5\nprint(greatest_common_divisor(0, 0))       # Expected output: 0 (or handle gracefully)\nprint(greatest_common_divisor(-25, 15))    # Expected output: 5\nprint(greatest_common_divisor(25, -15))    # Expected output: 5\nprint(greatest_common_divisor(-25, -15))   # Expected output: 5\nprint(greatest_common_divisor(1, 1))       # Expected output: 1\nprint(greatest_common_divisor(1, 1000000)) # Expected output: 1\nprint(greatest_common_divisor(1000000, 1)) # Expected output: 1\nprint(greatest_common_divisor(18, 24))     # Expected output: 6\nprint(greatest_common_divisor(17, 19))     # Expected output: 1", "result": "passed", "passed": true}
{"task_id": "HumanEval/14", "completion": "from typing import List, Union\n\ndef get_prefixes(string: str) -> List[str]:\n    return [string[:i] for i in range(1, len(string) + 1)]\n\ndef all_prefixes(input_string: Union[str, None]) -> List[str]:\n    if input_string is None:\n        return []\n    if not isinstance(input_string, str):\n        return []\n    if len(input_string) > 1000:\n        return [input_string[:i] for i in range(1, 1001)] + ['...']\n    return get_prefixes(input_string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/15", "completion": "def generate_numbers(n: int) -> list:\n    return list(range(n + 1))\n\ndef convert_to_string(numbers: list) -> str:\n    return ' '.join(map(str, numbers))\n\ndef string_sequence(n: int) -> str:\n    numbers = generate_numbers(n)\n    return convert_to_string(numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    def normalize_string(s: str) -> str:\n        return s.lower()\n    \n    def get_distinct_characters(s: str) -> set:\n        return set(c for c in s if c != \" \")\n    \n    normalized_string = normalize_string(string)\n    distinct_characters = get_distinct_characters(normalized_string)\n    \n    return len(distinct_characters)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    def note_to_beats(note: str) -> int:\n        if note == 'o':\n            return 4\n        elif note == 'o|':\n            return 2\n        elif note == '.|':\n            return 1\n        else:\n            return 0  # Return 0 for unknown note instead of raising an error\n\n    def split_notes(music_string: str) -> List[str]:\n        return [note for note in music_string.split() if note]\n\n    notes = split_notes(music_string)\n    beats = [note_to_beats(note) for note in notes if note_to_beats(note) > 0]\n    return beats", "result": "passed", "passed": true}
{"task_id": "HumanEval/18", "completion": "def count_overlapping_occurrences(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            break\n        count += 1\n        start += 1\n    return count\n\ndef how_many_times(string: str, substring: str) -> int:\n    return count_overlapping_occurrences(string, substring)", "result": "passed", "passed": true}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    if numbers is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(numbers, str):\n        raise ValueError(\"Input must be a string\")\n    \n    def word_to_num(word: str) -> int:\n        words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n        if word not in words:\n            raise ValueError(f\"Invalid number word: {word}\")\n        return words.index(word)\n    \n    words_list = numbers.split()\n    sorted_numbers = sorted(words_list, key=word_to_num)\n    return ' '.join(sorted_numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_distance = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(1, len(sorted_numbers)):\n        distance = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "result": "passed", "passed": true}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef find_min(numbers: List[float]) -> float:\n    return min(numbers)\n\ndef find_max(numbers: List[float]) -> float:\n    return max(numbers)\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = find_min(numbers)\n    max_val = find_max(numbers)\n    return [(num - min_val) / (max_val - min_val) for num in numbers]", "result": "passed", "passed": true}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef is_integer(value: Any) -> bool:\n    return isinstance(value, int) and not isinstance(value, bool)\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if is_integer(value)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    if string is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    return len(string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer greater than 0\")\n    if n == 1:\n        return 0\n\n    def find_divisor(n: int) -> int:\n        for i in range(n // 2, 0, -1):\n            if n % i == 0:\n                return i\n        return 1\n\n    return find_divisor(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/25", "completion": "from typing import List, Union\n\ndef factorize(n: Union[int, None]) -> List[int]:\n    if not isinstance(n, int) or n <= 1:\n        return []\n\n    def smallest_prime_factor(n: int) -> int:\n        if n % 2 == 0:\n            return 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return i\n        return n\n\n    def prime_factors(n: int) -> List[int]:\n        factors = []\n        while n > 1:\n            spf = smallest_prime_factor(n)\n            factors.append(spf)\n            n //= spf\n        return factors\n\n    return prime_factors(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/26", "completion": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "result": "passed", "passed": true}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    def flip_char(c: str) -> str:\n        return c.lower() if c.isupper() else c.upper()\n    \n    return ''.join(flip_char(c) for c in string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/28", "completion": "from typing import List, Union\n\ndef concatenate(strings: Union[List[str], None]) -> str:\n    if strings is None or not isinstance(strings, list):\n        raise ValueError(\"Input must be a list of strings\")\n    if not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"All elements must be strings\")\n    return ''.join(strings)", "result": "passed", "passed": true}
{"task_id": "HumanEval/29", "completion": "from typing import List, Optional\n\ndef filter_by_prefix(strings: Optional[List[str]], prefix: Optional[str]) -> List[str]:\n    if strings is None:\n        raise TypeError(\"The list of strings cannot be None\")\n    if prefix is None:\n        raise TypeError(\"The prefix cannot be None\")\n    \n    def starts_with_prefix(s: str, prefix: str) -> bool:\n        return s.startswith(prefix)\n    \n    return [s for s in strings if starts_with_prefix(s, prefix)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(x, (int, float)) for x in l):\n        raise TypeError(\"All elements of the list must be integers or floats.\")\n    return [x for x in l if x > 0]", "result": "passed", "passed": true}
{"task_id": "HumanEval/31", "completion": "import math\n\ndef is_prime(n):\n    if not isinstance(n, int):\n        return False\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/32", "completion": "import math\nfrom scipy.optimize import fsolve\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef poly_function(xs: list):\n    \"\"\"Returns a function that evaluates the polynomial for a given x.\"\"\"\n    def func(x):\n        return poly(xs, x)\n    return func\n\ndef find_zero(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"The list of coefficients must not be empty.\")\n    poly_func = poly_function(xs)\n    initial_guess = 0  # Initial guess for the root\n    zero = fsolve(poly_func, initial_guess)\n    return zero[0]\n\n# Example usage and tests:\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # f(x) = 1 + 2x, should print -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # (x - 1) * (x - 2) * (x - 3), should print 1.0", "result": "failed: 'NoneType' object is not callable", "passed": false}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    def extract_third_indices(lst):\n        return [lst[i] for i in range(len(lst)) if i % 3 == 0]\n\n    def insert_sorted_third_indices(lst, sorted_third):\n        sorted_iter = iter(sorted_third)\n        return [next(sorted_iter) if i % 3 == 0 else lst[i] for i in range(len(lst))]\n\n    third_indices_values = extract_third_indices(l)\n    sorted_third_indices = sorted([x for x in third_indices_values if x is not None])\n    \n    # Handle None values, maintaining their original positions\n    sorted_third_indices_with_none = []\n    sorted_iter = iter(sorted_third_indices)\n    for value in third_indices_values:\n        if value is None:\n            sorted_third_indices_with_none.append(None)\n        else:\n            sorted_third_indices_with_none.append(next(sorted_iter))\n    \n    return insert_sorted_third_indices(l, sorted_third_indices_with_none)", "result": "passed", "passed": true}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    def get_unique_elements(lst):\n        filtered_lst = [x for x in lst if x is not None]\n        return list(set(filtered_lst))\n    \n    def sort_elements(lst):\n        return sorted(lst)\n    \n    unique_elements = get_unique_elements(l)\n    sorted_unique_elements = sort_elements(unique_elements)\n    \n    return sorted_unique_elements", "result": "passed", "passed": true}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n\n    max_val = l[0]\n    for num in l:\n        if num is not None and (max_val is None or num > max_val):\n            max_val = num\n    return max_val", "result": "passed", "passed": true}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int):\n    if not isinstance(n, int):\n        raise TypeError(\"Input should be an integer\")\n    \n    def is_divisible_by_11_or_13(num: int) -> bool:\n        return num % 11 == 0 or num % 13 == 0\n\n    def count_digit_seven(num: int) -> int:\n        return str(num).count('7')\n\n    def count_sevens_in_range(limit: int) -> int:\n        count = 0\n        for i in range(limit):\n            if is_divisible_by_11_or_13(i):\n                count += count_digit_seven(i)\n        return count\n\n    return count_sevens_in_range(n)\n\n# Fix for the case where n is 144\ndef fizz_buzz(n: int):\n    if not isinstance(n, int):\n        raise TypeError(\"Input should be an integer\")\n    \n    def is_divisible_by_11_or_13(num: int) -> bool:\n        return num % 11 == 0 or num % 13 == 0\n\n    def count_digit_seven(num: int) -> int:\n        return str(num).count('7')\n\n    def count_sevens_in_range(limit: int) -> int:\n        count = 0\n        for i in range(limit):\n            if is_divisible_by_11_or_13(i):\n                count += count_digit_seven(i)\n        return count\n\n    return count_sevens_in_range(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    def get_even_indices(lst):\n        return [lst[i] for i in range(0, len(lst), 2) if lst[i] is not None]\n    \n    def set_even_indices(lst, sorted_evens):\n        j = 0\n        for i in range(0, len(lst), 2):\n            if lst[i] is not None:\n                lst[i] = sorted_evens[j]\n                j += 1\n        return lst\n    \n    def sort_list(lst):\n        return sorted(lst)\n    \n    even_indices = get_even_indices(l)\n    sorted_evens = sort_list(even_indices)\n    return set_even_indices(l, sorted_evens)\n\n# Example usage:\n# print(sort_even([1, 2, 3]))  # Output: [1, 2, 3]\n# print(sort_even([5, 6, 3, 4]))  # Output: [3, 6, 5, 4]\n# print(sort_even([None, 2, 3, 4, None, 6]))  # Output: [None, 2, 3, 4, None, 6]", "result": "passed", "passed": true}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str) -> str:\n    if s is None:\n        raise TypeError(\"Input cannot be None\")\n    groups = [s[i:i + 3] for i in range(0, len(s), 3)]\n    encoded_groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(encoded_groups)\n\ndef decode_cyclic(s: str) -> str:\n    if s is None:\n        raise TypeError(\"Input cannot be None\")\n    def decode_group(group: str) -> str:\n        return group[-1] + group[:-1] if len(group) == 3 else group\n    \n    groups = [s[i:i + 3] for i in range(0, len(s), 3)]\n    decoded_groups = [decode_group(group) for group in groups]\n    return \"\".join(decoded_groups)", "result": "passed", "passed": true}
{"task_id": "HumanEval/39", "completion": "import math\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef fibonacci_generator():\n    a, b = 0, 1\n    while True:\n        yield b\n        a, b = b, a + b\n\ndef prime_fib(n: int):\n    if not isinstance(n, int) or n <= 0:\n        return None\n    fib_gen = fibonacci_generator()\n    count = 0\n    while True:\n        fib_num = next(fib_gen)\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num", "result": "passed", "passed": true}
{"task_id": "HumanEval/40", "completion": "def has_triplet_with_zero_sum(nums):\n    nums = sorted(nums)\n    n = len(nums)\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef triples_sum_to_zero(l):\n    if l is None or len(l) < 3:\n        return False\n    return has_triplet_with_zero_sum(l)", "result": "passed", "passed": true}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Number of cars cannot be negative\")\n    return n * n", "result": "passed", "passed": true}
{"task_id": "HumanEval/42", "completion": "def increment_element(element: int) -> int:\n    return element + 1\n\ndef incr_list(l: list) -> list:\n    if not isinstance(l, list):\n        raise ValueError(\"Input should be a list\")\n    return [increment_element(x) if isinstance(x, int) else x for x in l]", "result": "passed", "passed": true}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    def has_pair_with_sum(l, target):\n        seen = set()\n        for number in l:\n            if target - number in seen:\n                return True\n            seen.add(number)\n        return False\n\n    return has_pair_with_sum(l, 0)", "result": "passed", "passed": true}
{"task_id": "HumanEval/44", "completion": "def change_base(x, base):\n    if not isinstance(x, int) or not isinstance(base, int):\n        raise ValueError(\"Both number and base must be integers\")\n    if base < 2 or base > 10:\n        raise ValueError(\"Base must be between 2 and 10\")\n    if x < 0:\n        raise ValueError(\"Number must be non-negative\")\n    \n    def convert_to_base(n, base):\n        if n == 0:\n            return \"\"\n        else:\n            return convert_to_base(n // base, base) + str(n % base)\n    \n    result = convert_to_base(x, base)\n    return result if result else \"0\"\n\n# Fix for the case `12345, 7` which was failing\ndef change_base(x, base):\n    if not isinstance(x, int) or not isinstance(base, int):\n        raise ValueError(\"Both number and base must be integers\")\n    if base < 2 or base > 10:\n        raise ValueError(\"Base must be between 2 and 10\")\n    if x < 0:\n        raise ValueError(\"Number must be non-negative\")\n    \n    def convert_to_base(n, base):\n        if n == 0:\n            return \"0\"\n        digits = []\n        while n:\n            digits.append(int(n % base))\n            n //= base\n        return ''.join(str(digit) for digit in digits[::-1])\n    \n    result = convert_to_base(x, base)\n    return result if result else \"0\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"\n    Given length of a side and height, return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    >>> triangle_area(5.5, 3.2)\n    8.8\n    >>> triangle_area(-5, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Base and height must be non-negative.\n    >>> triangle_area(5, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Base and height must be non-negative.\n    >>> triangle_area(\"5\", \"3\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Base and height must be numbers.\n    >>> triangle_area(None, 3)\n    Traceback (most recent call last):\n        ...\n    TypeError: Base and height must be numbers.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        raise TypeError(\"Base and height must be numbers.\")\n    if a < 0 or h < 0:\n        raise ValueError(\"Base and height must be non-negative.\")\n    return 0.5 * a * h", "result": "passed", "passed": true}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    fib4_seq = [0, 0, 2, 0]\n    \n    for i in range(4, n + 1):\n        next_value = fib4_seq[-1] + fib4_seq[-2] + fib4_seq[-3] + fib4_seq[-4]\n        fib4_seq.append(next_value)\n    \n    return fib4_seq[n]", "result": "passed", "passed": true}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\"\"\"\n    if not all(isinstance(x, (int, float)) for x in l):\n        raise TypeError(\"All elements in the list must be integers or floats\")\n    \n    if len(l) == 0:\n        return None\n    \n    def sort_list(lst):\n        return sorted(lst)\n    \n    def find_median(sorted_lst):\n        n = len(sorted_lst)\n        mid = n // 2\n        if n % 2 == 0:\n            return (sorted_lst[mid - 1] + sorted_lst[mid]) / 2\n        else:\n            return sorted_lst[mid]\n    \n    sorted_l = sort_list(l)\n    return find_median(sorted_l)\n\n# Example usage\nprint(median([3, 1, 2, 4, 5]))  # Output: 3\nprint(median([-10, 4, 6, 1000, 10, 20]))  # Output: 8.0", "result": "passed", "passed": true}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    def clean_text(text: str) -> str:\n        return ''.join(char.lower() for char in text if char.isalnum())\n    \n    def check_palindrome(cleaned_text: str) -> bool:\n        return cleaned_text == cleaned_text[::-1]\n    \n    cleaned_text = clean_text(text)\n    return check_palindrome(cleaned_text)", "result": "passed", "passed": true}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if not isinstance(n, int) or not isinstance(p, int):\n        raise ValueError(\"Both n and p must be integers.\")\n    if p <= 0:\n        raise ValueError(\"Modulus p must be a positive integer.\")\n    if n < 0:\n        raise ValueError(\"Exponent n must be a non-negative integer.\")\n    \n    def power_mod(base, exponent, modulus):\n        result = 1\n        base = base % modulus\n        while exponent > 0:\n            if (exponent % 2) == 1:\n                result = (result * base) % modulus\n            exponent = exponent >> 1\n            base = (base * base) % modulus\n        return result\n\n    return power_mod(2, n, p)", "result": "passed", "passed": true}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    def shift_char(ch: str, shift: int) -> str:\n        if 'a' <= ch <= 'z':\n            return chr(((ord(ch) - ord('a') + shift) % 26) + ord('a'))\n        elif 'A' <= ch <= 'Z':\n            return chr(((ord(ch) - ord('A') + shift) % 26) + ord('A'))\n        else:\n            return ch\n    \n    return \"\".join(shift_char(ch, 5) for ch in s)\n\ndef decode_shift(s: str) -> str:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    def shift_char(ch: str, shift: int) -> str:\n        if 'a' <= ch <= 'z':\n            return chr(((ord(ch) - ord('a') - shift) % 26) + ord('a'))\n        elif 'A' <= ch <= 'Z':\n            return chr(((ord(ch) - ord('A') - shift) % 26) + ord('A'))\n        else:\n            return ch\n    \n    return \"\".join(shift_char(ch, 5) for ch in s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    if text is None:\n        raise TypeError(\"Input text cannot be None\")\n    \n    def is_vowel(char):\n        return char.lower() in 'aeiou'\n    \n    return ''.join(char for char in text if not is_vowel(char))\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "HumanEval/52", "completion": "def all_below(l: list, t: int) -> bool:\n    if not isinstance(l, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(t, (int, float)):\n        raise TypeError(\"The threshold must be a numeric value.\")\n    for number in l:\n        if not isinstance(number, (int, float)):\n            raise TypeError(\"All elements in the list must be numeric values.\")\n        if number >= t:\n            return False\n    return True\n\ndef below_threshold(l: list, t: int) -> bool:\n    return all_below(l, t)", "result": "passed", "passed": true}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    >>> add(-1, 1)\n    0\n    >>> add(0, 0)\n    0\n    >>> add(-5, -10)\n    -15\n    >>> add(1000000, 2000000)\n    3000000\n    >>> add(2147483647, 1)\n    2147483648\n    >>> add(-2147483648, -1)\n    -2147483649\n    >>> add(None, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers\n    >>> add(1, None)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers\n    >>> add(\"a\", \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers\n    >>> add(3.5, 2.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers\n    >>> add(5, \"10\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments must be integers\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both arguments must be integers\")\n    return x + y\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0, s1):\n    if not isinstance(s0, str) or not isinstance(s1, str):\n        raise TypeError(\"Both inputs must be strings\")\n    \n    return set(s0) == set(s1)", "result": "passed", "passed": true}
{"task_id": "HumanEval/55", "completion": "def fib(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n+1):\n        a, b = b, a + b\n    return b", "result": "passed", "passed": true}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets):\n    if not isinstance(brackets, str):\n        raise TypeError(\"Input must be a string\")\n\n    def is_balanced(brackets: str) -> bool:\n        balance = 0\n        for bracket in brackets:\n            if bracket == '<':\n                balance += 1\n            elif bracket == '>':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    return is_balanced(brackets)", "result": "passed", "passed": true}
{"task_id": "HumanEval/57", "completion": "def is_increasing(l):\n    return all(x <= y for x, y in zip(l, l[1:]))\n\ndef is_decreasing(l):\n    return all(x >= y for x, y in zip(l, l[1:]))\n\ndef monotonic(l: list):\n    if not l:\n        return True\n    if len(l) == 1:\n        return True\n    return is_increasing(l) or is_decreasing(l)", "result": "passed", "passed": true}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    if not isinstance(l1, list) or not isinstance(l2, list):\n        raise TypeError(\"Both inputs must be lists\")\n    if l1 is None or l2 is None:\n        raise ValueError(\"Neither input can be None\")\n    \n    def find_common_elements(list1, list2):\n        return set(list1).intersection(set(list2))\n    \n    def sort_elements(elements):\n        try:\n            return sorted(elements)\n        except TypeError:\n            return sorted(elements, key=lambda x: (isinstance(x, str), x))\n    \n    common_elements = find_common_elements(l1, l2)\n    sorted_common_elements = sort_elements(common_elements)\n    \n    return sorted_common_elements", "result": "passed", "passed": true}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    if n is None or n <= 1:\n        return None\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def smallest_prime_factor(num: int) -> int:\n        if num % 2 == 0:\n            return 2\n        i = 3\n        while i * i <= num:\n            if num % i == 0:\n                return i\n            i += 2\n        return num\n\n    def largest_prime_factor_inner(num: int) -> int:\n        factor = smallest_prime_factor(num)\n        while factor < num:\n            num //= factor\n            factor = smallest_prime_factor(num)\n        return num\n\n    if is_prime(n):\n        return None\n\n    return largest_prime_factor_inner(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        return 0\n    return n * (n + 1) // 2", "result": "passed", "passed": true}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\n    if brackets is None or not isinstance(brackets, str):\n        raise TypeError(\"Input must be a string\")\n\n    def is_balanced(brackets: str) -> bool:\n        balance = 0\n        for char in brackets:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            elif char not in '()':  # Check for invalid characters\n                return False\n            if balance < 0:\n                return False\n        return balance == 0\n\n    return is_balanced(brackets)", "result": "passed", "passed": true}
{"task_id": "HumanEval/62", "completion": "def derivative(xs):\n    if xs is None:\n        raise ValueError(\"Input cannot be None\")\n        \n    if not isinstance(xs, list):\n        raise TypeError(\"Input must be a list\")\n    \n    if not all(isinstance(x, (int, float)) for x in xs):\n        raise ValueError(\"All elements of the list must be integers or floats\")\n    \n    def compute_derivative(coefficients):\n        return [coefficients[i] * i for i in range(1, len(coefficients))]\n\n    return compute_derivative(xs)", "result": "passed", "passed": true}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        return None\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    memo = {0: 0, 1: 0, 2: 1}\n    for i in range(3, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2] + memo[i - 3]\n    \n    return memo[n]\n\n# Improved implementation using iterative approach with space optimization\ndef fibfib(n: int) -> int:\n    if not isinstance(n, int) or n < 0:\n        return None\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    return c", "result": "passed", "passed": true}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    def is_vowel(char, is_last):\n        vowels = 'aeiou'\n        if char.lower() in vowels:\n            return True\n        if char.lower() == 'y' and is_last:\n            return True\n        return False\n\n    def count_vowels(word):\n        count = 0\n        for i, char in enumerate(word):\n            if is_vowel(char, i == len(word) - 1):\n                count += 1\n        return count\n\n    words = s.split()\n    total_vowels = 0\n    for word in words:\n        total_vowels += count_vowels(word)\n    \n    return total_vowels", "result": "passed", "passed": true}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    def reverse_digits(digits):\n        return digits[::-1]\n\n    def shift_digits(digits, shift):\n        shift = shift % len(digits)\n        return digits[-shift:] + digits[:-shift]\n\n    digits = str(x)\n    if shift > len(digits):\n        return reverse_digits(digits)\n    return shift_digits(digits, shift)", "result": "passed", "passed": true}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    if s is None:\n        raise TypeError(\"Input cannot be None\")\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    def is_upper(c):\n        return 'A' <= c <= 'Z'\n\n    def ascii_value(c):\n        return ord(c)\n\n    def sum_upper_chars(s):\n        return sum(ascii_value(c) for c in s if is_upper(c))\n\n    return sum_upper_chars(s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/67", "completion": "import re\n\ndef extract_numbers(s):\n    return list(map(int, re.findall(r'\\d+', s)))\n\ndef calculate_mangoes(apples_oranges, total_fruits):\n    return total_fruits - sum(apples_oranges)\n\ndef fruit_distribution(data):\n    if not isinstance(data, tuple) or len(data) != 2:\n        raise ValueError(\"Input must be a tuple with two elements.\")\n    \n    s, n = data\n    if not isinstance(s, str) or not isinstance(n, int):\n        raise ValueError(\"First element of the tuple must be a string and the second element must be an integer.\")\n    \n    apples_oranges = extract_numbers(s)\n    return calculate_mangoes(apples_oranges, n)", "result": "failed: fruit_distribution() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    if arr is None:\n        return []\n\n    def find_smallest_even(arr):\n        smallest_value = float('inf')\n        smallest_index = -1\n        for idx, value in enumerate(arr):\n            if value % 2 == 0 and value < smallest_value:\n                smallest_value = value\n                smallest_index = idx\n        return smallest_value, smallest_index\n\n    def is_valid_result(value, index):\n        return index != -1\n\n    def format_result(value, index):\n        return [value, index]\n\n    smallest_value, smallest_index = find_smallest_even(arr)\n    if is_valid_result(smallest_value, smallest_index):\n        return format_result(smallest_value, smallest_index)\n    else:\n        return []\n\n# Example usage\nprint(pluck([4, 2, 3]))  # Output: [2, 1]\nprint(pluck([1, 2, 3]))  # Output: [2, 1]\nprint(pluck([]))         # Output: []\nprint(pluck([5, 0, 3, 0, 4, 2]))  # Output: [0, 1]\nprint(pluck(None))       # Output: []", "result": "passed", "passed": true}
{"task_id": "HumanEval/69", "completion": "from collections import Counter\n\ndef analyze_frequency(lst):\n    return Counter(lst)\n\ndef find_valid_numbers(freq_dict):\n    valid_numbers = [num for num, count in freq_dict.items() if count >= num]\n    return valid_numbers\n\ndef find_greatest_number(valid_numbers):\n    return max(valid_numbers) if valid_numbers else -1\n\ndef search(lst):\n    if not lst:\n        return -1\n    freq_dict = analyze_frequency(lst)\n    valid_numbers = find_valid_numbers(freq_dict)\n    return find_greatest_number(valid_numbers)", "result": "passed", "passed": true}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    def get_min(lst):\n        return min(lst)\n    \n    def get_max(lst):\n        return max(lst)\n    \n    def remove_element(lst, element):\n        lst.remove(element)\n        return lst\n    \n    def strange_sort(lst):\n        sorted_lst = []\n        while lst:\n            sorted_lst.append(get_min(lst))\n            lst = remove_element(lst, sorted_lst[-1])\n            if lst:\n                sorted_lst.append(get_max(lst))\n                lst = remove_element(lst, sorted_lst[-1])\n        return sorted_lst\n    \n    return strange_sort(lst)", "result": "passed", "passed": true}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef is_valid_triangle(a, b, c):\n    if not all(isinstance(side, (int, float)) for side in [a, b, c]):\n        return False\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    return a + b > c and a + c > b and b + c > a\n\ndef calculate_area(a, b, c):\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef triangle_area(a, b, c):\n    if not is_valid_triangle(a, b, c):\n        return -1\n    area = calculate_area(a, b, c)\n    return round(area, 2)", "result": "passed", "passed": true}
{"task_id": "HumanEval/72", "completion": "def is_palindromic(lst):\n    return lst == lst[::-1]\n\ndef will_it_fly(q, w):\n    if q is None or w is None or w < 0:\n        return False\n    return is_palindromic(q) and sum(q) <= w", "result": "passed", "passed": true}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    def count_changes_to_palindrome(arr):\n        n = len(arr)\n        changes = 0\n        for i in range(n // 2):\n            if arr[i] != arr[n - i - 1]:\n                changes += 1\n        return changes\n\n    return count_changes_to_palindrome(arr)", "result": "passed", "passed": true}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    if not isinstance(lst1, list) or not isinstance(lst2, list):\n        raise TypeError(\"Both arguments must be lists\")\n    \n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    if total_chars(lst1) < total_chars(lst2):\n        return lst1\n    elif total_chars(lst1) > total_chars(lst2):\n        return lst2\n    else:\n        return lst1", "result": "passed", "passed": true}
{"task_id": "HumanEval/75", "completion": "from itertools import combinations\nfrom math import isqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef get_primes_below_100():\n    primes = []\n    for num in range(2, 100):\n        if is_prime(num):\n            primes.append(num)\n    return primes\n\ndef is_multiply_prime(a):\n    if not isinstance(a, int) or a <= 0:\n        return False\n    primes = get_primes_below_100()\n    for combo in combinations(primes, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n    return False\n\n# Fix for handling input that is not an integer\ndef is_multiply_prime_input(a):\n    try:\n        a = int(float(a))  # Convert to float first to handle cases like '1.0'\n    except (ValueError, TypeError):\n        return False\n    return is_multiply_prime(a)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/76", "completion": "import math\n\ndef is_simple_power(x, n):\n    if x == 1:\n        return True\n    if x == 0 or n == 0:\n        return False\n    if n == 1:\n        return x == 1\n    if n < 0:\n        if x <= 0:\n            return False\n        x = 1 / x\n        n = -n\n    if x < 0 and n % 2 == 0:\n        return False\n    # Absolute value of x for log calculation\n    log_result = math.log(abs(x), abs(n))\n    # Check if log_result is close to an integer\n    return math.isclose(log_result, round(log_result))\n\n# Test cases\nprint(is_simple_power(1, 4))  # True\nprint(is_simple_power(2, 2))  # True\nprint(is_simple_power(8, 2))  # True\nprint(is_simple_power(3, 2))  # False\nprint(is_simple_power(3, 1))  # False\nprint(is_simple_power(5, 3))  # False\nprint(is_simple_power(0, 2))  # False\nprint(is_simple_power(4, 0))  # False\nprint(is_simple_power(0, 0))  # False\nprint(is_simple_power(1, 1))  # True\nprint(is_simple_power(27, 3))  # True\nprint(is_simple_power(-8, -2))  # True\nprint(is_simple_power(-8, 2))  # False\nprint(is_simple_power(8, -2))  # False\nprint(is_simple_power(16, 0.5))  # True\nprint(is_simple_power(16, 4))  # True", "result": "passed", "passed": true}
{"task_id": "HumanEval/77", "completion": "def is_perfect_cube(n):\n    if n < 0:\n        cube_root = round((-n) ** (1/3))\n        return -cube_root ** 3 == n\n    else:\n        cube_root = round(n ** (1/3))\n        return cube_root ** 3 == n\n\ndef iscube(a):\n    return is_perfect_cube(a)", "result": "passed", "passed": true}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    def is_prime_hex_digit(digit):\n        return digit.upper() in prime_hex_digits\n    \n    def count_prime_hex_digits(hex_string):\n        return sum(1 for digit in hex_string if is_prime_hex_digit(digit))\n    \n    return count_prime_hex_digits(num)\n\n# Test the function\nprint(hex_key(\"FECBA9876543210\"))  # Expected output: 6 (2, 3, 5, 7, B, D)", "result": "passed", "passed": true}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer\")\n    \n    def convert_to_binary(n):\n        if n < 0:\n            return '-' + bin(n)[3:]\n        return bin(n)[2:]\n\n    def add_formatting(binary_str):\n        return f\"db{binary_str}db\"\n\n    binary_str = convert_to_binary(decimal)\n    return add_formatting(binary_str)", "result": "passed", "passed": true}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    if s is None or len(s) < 3:\n        return False\n\n    def has_distinct_triplets(s):\n        for i in range(len(s) - 2):\n            if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n                return False\n        return True\n\n    return has_distinct_triplets(s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    def get_letter_grade(gpa):\n        if gpa is None or not isinstance(gpa, (int, float)) or gpa < 0:\n            raise ValueError(\"Invalid GPA value\")\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa >= 3.7:\n            return 'A'\n        elif gpa >= 3.3:\n            return 'A-'\n        elif gpa >= 3.0:\n            return 'B+'\n        elif gpa >= 2.7:\n            return 'B'\n        elif gpa >= 2.3:\n            return 'B-'\n        elif gpa >= 2.0:\n            return 'C+'\n        elif gpa >= 1.7:\n            return 'C'\n        elif gpa >= 1.3:\n            return 'C-'\n        elif gpa >= 1.0:\n            return 'D+'\n        elif gpa >= 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    \n    result = []\n    for gpa in grades:\n        try:\n            result.append(get_letter_grade(gpa))\n        except ValueError as e:\n            result.append(str(e))\n    return result", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/82", "completion": "def is_prime(n):\n    if not isinstance(n, int) or n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(string):\n    if not isinstance(string, str):\n        return False\n    return is_prime(len(string))", "result": "passed", "passed": true}
{"task_id": "HumanEval/83", "completion": "def count_numbers_with_1_at_ends(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return 18 * 10**(n-2) + 2 if n > 1 else 0\n\ndef starts_one_ends(n):\n    return count_numbers_with_1_at_ends(n)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/84", "completion": "def int_to_binary(n):\n    return bin(n)[2:]\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef solve(N):\n    digit_sum = sum_of_digits(N)\n    return int_to_binary(digit_sum)", "result": "passed", "passed": true}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if isinstance(lst[i], int) and lst[i] % 2 == 0)", "result": "passed", "passed": true}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    if s is None:\n        return None\n\n    def sort_word(word):\n        alpha_chars = sorted([c for c in word if c.isalpha()], key=lambda c: (c.lower(), c))\n        result = []\n        alpha_index = 0\n        for c in word:\n            if c.isalpha():\n                result.append(alpha_chars[alpha_index])\n                alpha_index += 1\n            else:\n                result.append(c)\n        return ''.join(result)\n\n    def process_sentence(sentence):\n        words = sentence.split(' ')\n        sorted_words = [sort_word(word) for word in words]\n        return ' '.join(sorted_words)\n    \n    return process_sentence(s)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    def find_coordinates(matrix, target):\n        coordinates = []\n        for row_idx, row in enumerate(matrix):\n            for col_idx, value in enumerate(row):\n                if value == target:\n                    coordinates.append((row_idx, col_idx))\n        return coordinates\n\n    def sort_coordinates(coords):\n        coords.sort(key=lambda coord: (coord[0], coord[1]))\n        return coords\n\n    coordinates = find_coordinates(lst, x)\n    sorted_coordinates = sort_coordinates(coordinates)\n    return sorted_coordinates\n\n# Example usage:\nprint(get_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/88", "completion": "def analyze_condition(array):\n    if not array:\n        return None  # No sorting needed for empty array\n    return (array[0] + array[-1]) % 2 != 0\n\ndef sort_in_ascending_order(array):\n    return sorted(array)\n\ndef sort_in_descending_order(array):\n    return sorted(array, reverse=True)\n\ndef sort_array(array):\n    if not array:\n        return array\n    condition = analyze_condition(array)\n    if condition:\n        return sort_in_ascending_order(array)\n    else:\n        return sort_in_descending_order(array)", "result": "passed", "passed": true}
{"task_id": "HumanEval/89", "completion": "def rotate_char(c, shift):\n    if 'a' <= c <= 'z':\n        return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n    elif 'A' <= c <= 'Z':\n        return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n    return c\n\ndef encrypt(s, shift=4):\n    return ''.join(rotate_char(c, shift) for c in s if c is not None)", "result": "passed", "passed": true}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = list(set(lst))\n    \n    if len(unique_lst) < 2:\n        return None\n    \n    unique_lst.sort()\n    \n    return unique_lst[1]", "result": "passed", "passed": true}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    if not isinstance(S, str):\n        raise TypeError(\"Input should be a string\")\n    \n    def split_sentences(text):\n        import re\n        return re.split(r'[.!?]', text)\n    \n    def count_boredoms(sentences):\n        return sum(1 for sentence in sentences if sentence.strip().startswith('I'))\n    \n    sentences = split_sentences(S)\n    return count_boredoms(sentences)", "result": "failed: Test 2", "passed": false}
{"task_id": "HumanEval/92", "completion": "def is_integer(num):\n    return isinstance(num, int)\n\ndef check_sum(a, b, c):\n    return a == b + c or b == a + c or c == a + b\n\ndef any_int(x, y, z):\n    if all(map(is_integer, [x, y, z])):\n        return check_sum(x, y, z)\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    def swap_case(char):\n        return char.lower() if char.isupper() else char.upper()\n    \n    def replace_vowel(char):\n        vowels = 'aeiouAEIOU'\n        replacements = 'cgkqwCGKQW'\n        if char in vowels:\n            return replacements[vowels.index(char)]\n        return char\n    \n    def process_char(char):\n        if char in 'aeiouAEIOU':\n            return replace_vowel(swap_case(char))\n        else:\n            return swap_case(char)\n    \n    return ''.join(process_char(char) for char in message)", "result": "passed", "passed": true}
{"task_id": "HumanEval/94", "completion": "import math\n\ndef is_prime(n):\n    if not isinstance(n, int):  # Ensure n is an integer\n        return False\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef largest_prime(lst):\n    primes = [x for x in lst if is_prime(x)]\n    return max(primes) if primes else None\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    if not isinstance(lst, list):  # Ensure lst is a list\n        return 0\n    largest = largest_prime(lst)\n    if largest is not None:\n        return sum_of_digits(largest)\n    return 0", "result": "passed", "passed": true}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(d):\n    if not d:\n        return False\n    \n    def is_all_lower(keys):\n        return all(isinstance(k, str) and k.islower() for k in keys)\n    \n    def is_all_upper(keys):\n        return all(isinstance(k, str) and k.isupper() for k in keys)\n    \n    keys = d.keys()\n    return is_all_lower(keys) or is_all_upper(keys)", "result": "passed", "passed": true}
{"task_id": "HumanEval/96", "completion": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "result": "passed", "passed": true}
{"task_id": "HumanEval/97", "completion": "def get_unit_digit(n):\n    return abs(n) % 10\n\ndef multiply(a, b):\n    unit_digit_a = get_unit_digit(a)\n    unit_digit_b = get_unit_digit(b)\n    return unit_digit_a * unit_digit_b", "result": "passed", "passed": true}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    if s is None:\n        return 0\n\n    def is_upper_vowel(c):\n        return c in 'AEIOU'\n\n    def is_even_index(i):\n        return i % 2 == 0\n\n    def count_vowels_at_even_indices(s):\n        count = 0\n        for i in range(len(s)):\n            if is_even_index(i) and is_upper_vowel(s[i]):\n                count += 1\n        return count\n\n    return count_vowels_at_even_indices(s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/99", "completion": "import math\n\ndef parse_value(value):\n    try:\n        return float(value)\n    except (ValueError, TypeError):\n        raise ValueError(\"Invalid input: must be a numeric string or a number.\")\n\ndef round_away_from_zero(value):\n    if value > 0:\n        return math.ceil(value)\n    else:\n        return math.floor(value)\n\ndef closest_integer(value):\n    num = parse_value(value)\n    if num - int(num) == 0.5:\n        return round_away_from_zero(num)\n    elif num - int(num) == -0.5:\n        return round_away_from_zero(num)\n    else:\n        return int(round(num))", "result": "passed", "passed": true}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n    \n    def next_odd(x):\n        return x + 2 if x % 2 != 0 else x + 1\n    \n    def next_even(x):\n        return x + 2 if x % 2 == 0 else x + 1\n    \n    def generate_pile(n):\n        pile = [n]\n        current = n\n        for _ in range(1, n):\n            if n % 2 == 0:\n                current = next_even(current)\n            else:\n                current = next_odd(current)\n            pile.append(current)\n        return pile\n    \n    return generate_pile(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/101", "completion": "import re\n\ndef split_string(s):\n    if s is None:\n        return None\n    if not s.strip():\n        return []\n    return [word for word in re.split(r'[,\\s]+', s.strip()) if word]\n\ndef words_string(s):\n    return split_string(s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/102", "completion": "def is_even(n):\n    return n % 2 == 0\n\ndef find_largest_even(x, y):\n    for num in range(y, x-1, -1):\n        if is_even(num):\n            return num\n    return -1\n\ndef choose_num(x, y):\n    if x > y:\n        return -1\n    return find_largest_even(x, y)", "result": "passed", "passed": true}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    if n is None or m is None or n < 0 or m < 0 or n > m:\n        return -1\n\n    def calculate_avg(n, m):\n        total_sum = sum(range(n, m + 1))\n        count = m - n + 1\n        return total_sum / count\n\n    def round_to_nearest_int(value):\n        return round(value)\n\n    def convert_to_binary(value):\n        return bin(value)\n\n    avg = calculate_avg(n, m)\n    rounded_avg = round_to_nearest_int(avg)\n    binary_result = convert_to_binary(rounded_avg)\n    \n    return binary_result\n\n# Test cases\nprint(rounded_avg(1, 5))  # Expected: \"0b11\"\nprint(rounded_avg(7, 5))  # Expected: -1\nprint(rounded_avg(10, 20))  # Expected: \"0b1111\"\nprint(rounded_avg(20, 33))  # Expected: \"0b11010\"\nprint(rounded_avg(0, 0))  # Expected: \"0b0\"\nprint(rounded_avg(100, 100))  # Expected: \"0b1100100\"\nprint(rounded_avg(1, 1))  # Expected: \"0b1\"\nprint(rounded_avg(1, 2))  # Expected: \"0b10\"\nprint(rounded_avg(-5, 5))  # Expected: -1\nprint(rounded_avg(5, -5))  # Expected: -1\nprint(rounded_avg(None, 5))  # Expected: -1\nprint(rounded_avg(5, None))  # Expected: -1\nprint(rounded_avg(1, 1000000))  # Expected: \"0b11110100001001000000\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    def has_even_digit(n):\n        if n == 0:\n            return True\n        while n > 0:\n            if (n % 10) % 2 == 0:\n                return True\n            n //= 10\n        return False\n    \n    def filter_numbers(lst):\n        return [num for num in lst if not has_even_digit(num)]\n    \n    def sort_numbers(lst):\n        return sorted(lst)\n    \n    filtered_numbers = filter_numbers(x)\n    sorted_numbers = sort_numbers(filtered_numbers)\n    return sorted_numbers", "result": "passed", "passed": true}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    def filter_and_sort(arr):\n        return sorted([num for num in arr if isinstance(num, int) and 1 <= num <= 9])\n\n    def reverse_array(arr):\n        return arr[::-1]\n\n    def replace_with_names(arr):\n        num_to_name = {\n            1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", \n            5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n        }\n        return [num_to_name[num] for num in arr]\n\n    if arr is None:\n        return []\n\n    filtered_sorted = filter_and_sort(arr)\n    reversed_arr = reverse_array(filtered_sorted)\n    return replace_with_names(reversed_arr)", "result": "passed", "passed": true}
{"task_id": "HumanEval/106", "completion": "import math\n\ndef factorial(num):\n    return math.factorial(num)\n\ndef sum_to(num):\n    return sum(range(1, num + 1))\n\ndef f(n):\n    if n is None:\n        raise TypeError(\"'NoneType' object cannot be interpreted as an integer\")\n    if n < 0:\n        return []\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_to(i))\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n    \n    def count_even_odd_palindromes(limit):\n        even_count, odd_count = 0, 0\n        for i in range(1, limit + 1):\n            if is_palindrome(i):\n                if i % 2 == 0:\n                    even_count += 1\n                else:\n                    odd_count += 1\n        return even_count, odd_count\n    \n    if n <= 0:\n        return (0, 0)\n    \n    return count_even_odd_palindromes(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    if arr is None:\n        return 0\n\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    def has_positive_sum_of_digits(n):\n        return sum_of_digits(n) > 0\n\n    return sum(1 for num in arr if has_positive_sum_of_digits(num))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/109", "completion": "def is_sorted(arr):\n    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\ndef move_one_ball(arr):\n    if not arr:\n        return True\n    \n    n = len(arr)\n    for i in range(n):\n        if is_sorted(arr):\n            return True\n        arr = arr[1:] + arr[:1]\n    \n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/110", "completion": "def is_even(n):\n    return n % 2 == 0\n\ndef exchange(lst1, lst2):\n    lst1_evens = [x for x in lst1 if is_even(x)]\n    lst2_evens = [x for x in lst2 if is_even(x)]\n    \n    if len(lst1_evens) == len(lst1):\n        return \"YES\"\n    \n    if len(lst1_evens) + len(lst2_evens) >= len(lst1):\n        return \"YES\"\n    \n    return \"NO\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    from collections import Counter\n    \n    def count_letters(test):\n        if not test:\n            return Counter()\n        return Counter(test.split())\n    \n    def max_repetition(counts):\n        if not counts:\n            return {}\n        max_count = max(counts.values())\n        return {letter: count for letter, count in counts.items() if count == max_count}\n    \n    counts = count_letters(test)\n    return max_repetition(counts)", "result": "passed", "passed": true}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    if s is None or c is None:\n        raise ValueError(\"Input strings cannot be None\")\n\n    def remove_chars(s, c):\n        return ''.join(char for char in s if char not in c)\n    \n    def is_palindrome(s):\n        s = ''.join(char.lower() for char in s if char.isalnum())  # Normalize by removing non-alphanumeric characters and converting to lowercase\n        return s == s[::-1]\n    \n    cleaned_string = remove_chars(s, c)\n    palindrome_check = is_palindrome(cleaned_string)\n    \n    return (cleaned_string, palindrome_check)", "result": "passed", "passed": true}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    if lst is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    def count_odds(s):\n        if not s.isdigit():\n            raise ValueError(\"String contains non-digit characters\")\n        return sum(1 for char in s if char in '13579')\n    \n    def generate_output_string(s, count):\n        template = \"the number of odd elements in the string {} is {} of the input.\"\n        return template.format(s, count)\n    \n    return [generate_output_string(s, count_odds(s)) for s in lst]\n\n# Example usage\nprint(odd_count(['1234567']))  # [\"the number of odd elements in the string 1234567 is 4 of the input.\"]\nprint(odd_count(['3', \"11111111\"]))  # [\"the number of odd elements in the string 3 is 1 of the input.\", \"the number of odd elements in the string 11111111 is 8 of the input.\"]", "result": "failed: Test 1", "passed": false}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    if not nums:\n        return None\n    \n    def find_min_subarray_sum(nums):\n        current_sum = 0\n        min_sum = float('inf')\n        for num in nums:\n            current_sum += num\n            if current_sum < min_sum:\n                min_sum = current_sum\n            # Reset current_sum only if it is positive\n            if current_sum > 0:\n                current_sum = 0\n        return min_sum\n\n    return find_min_subarray_sum(nums)\n\n# Additional handling for single element arrays\nif len(nums) == 1:\n    return nums[0]", "result": "failed: 'return' outside function (<string>, line 30)", "passed": false}
{"task_id": "HumanEval/115", "completion": "import math\n\ndef count_water_units(grid):\n    return sum(sum(row) for row in grid if isinstance(row, list) and all(isinstance(i, int) for i in row))\n\ndef calculate_bucket_uses(total_water, capacity):\n    return math.ceil(total_water / capacity)\n\ndef max_fill(grid, capacity):\n    total_water = count_water_units(grid)\n    return calculate_bucket_uses(total_water, capacity)", "result": "failed: Error", "passed": false}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    def count_ones(n):\n        return bin(n).count('1')\n    \n    def sort_key(n):\n        return (count_ones(n), n)\n    \n    if any(n < 0 for n in arr):\n        raise ValueError(\"Input contains negative integers, which are not allowed.\")\n    \n    return sorted(arr, key=sort_key)", "result": "failed: Input contains negative integers, which are not allowed.", "passed": false}
{"task_id": "HumanEval/117", "completion": "def is_consonant(c):\n    return isinstance(c, str) and c.lower() in 'bcdfghjklmnpqrstvwxyz'\n\ndef count_consonants(word):\n    return sum(1 for c in word if is_consonant(c))\n\ndef select_words(s, n):\n    if not isinstance(s, str):\n        return []\n    \n    words = s.split()\n    result = [word for word in words if count_consonants(word) == n]\n    \n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    vowels = set('AEIOUaeiou')\n\n    def is_vowel(c):\n        return c in vowels\n\n    def find_closest_vowel(word):\n        for i in range(len(word) - 2):\n            if not is_vowel(word[i]) and is_vowel(word[i + 1]) and not is_vowel(word[i + 2]):\n                return word[i + 1]\n        return \"\"\n\n    closest_vowel = \"\"\n    for i in range(len(word) - 2, -1, -1):\n        if not is_vowel(word[i]) and is_vowel(word[i + 1]) and not is_vowel(word[i + 2]):\n            closest_vowel = word[i + 1]\n            break\n    return closest_vowel\n\n    return find_closest_vowel(word)", "result": "failed: string index out of range", "passed": false}
{"task_id": "HumanEval/119", "completion": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n\ndef match_parens(lst):\n    s1, s2 = lst\n    if s1 is None or s2 is None:\n        return 'No'\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "result": "passed", "passed": true}
{"task_id": "HumanEval/120", "completion": "import heapq\n\ndef analyze_requirements(arr, k):\n    return k <= len(arr)\n\ndef get_max_k_elements(arr, k):\n    return heapq.nlargest(k, arr)\n\ndef sort_elements(elements):\n    return sorted(elements)\n\ndef maximum(arr, k):\n    if not analyze_requirements(arr, k):\n        return []\n    max_elements = get_max_k_elements(arr, k)\n    return sort_elements(max_elements)", "result": "passed", "passed": true}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    def is_odd(n):\n        return n % 2 != 0\n\n    def sum_of_odds_at_even_positions(lst):\n        return sum(lst[i] for i in range(0, len(lst), 2) if is_odd(lst[i]))\n\n    return sum_of_odds_at_even_positions(lst)", "result": "passed", "passed": true}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    def is_two_digits(n):\n        return -99 <= n <= 99\n    \n    def sum_two_digit_elements(sub_arr):\n        return sum(x for x in sub_arr if is_two_digits(x))\n    \n    return sum_two_digit_elements(arr[:k])", "result": "passed", "passed": true}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    def collatz_sequence(n):\n        sequence = []\n        while n != 1:\n            sequence.append(n)\n            if n % 2 == 0:\n                n //= 2\n            else:\n                n = 3 * n + 1\n        sequence.append(1)\n        return sequence\n\n    def filter_odd_numbers(sequence):\n        return sorted([x for x in sequence if x % 2 != 0])\n\n    sequence = collatz_sequence(n)\n    odd_numbers = filter_odd_numbers(sequence)\n    return odd_numbers", "result": "passed", "passed": true}
{"task_id": "HumanEval/124", "completion": "import re\n\ndef is_valid_format(date):\n    return bool(re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date))\n\ndef is_valid_month(month):\n    return 1 <= month <= 12\n\ndef is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef is_valid_day(day, month, year):\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        return 1 <= day <= 31\n    elif month in {4, 6, 9, 11}:\n        return 1 <= day <= 30\n    elif month == 2:\n        if is_leap_year(year):\n            return 1 <= day <= 29\n        else:\n            return 1 <= day <= 28\n    return False\n\ndef valid_date(date):\n    if not date or not isinstance(date, str):\n        return False\n    \n    if not is_valid_format(date):\n        return False\n    \n    month, day, year = map(int, date.split('-'))\n    \n    if not is_valid_month(month):\n        return False\n    \n    if not is_valid_day(day, month, year):\n        return False\n    \n    return True", "result": "passed", "passed": true}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    import string\n\n    def count_odd_lowercase_letters(s):\n        return sum(1 for c in s if c.islower() and (ord(c) - ord('a')) % 2 == 0)\n\n    def split_on_whitespace(s):\n        return s.split()\n\n    def split_on_comma(s):\n        return s.split(',')\n\n    def main_function(s):\n        if s is None:\n            raise TypeError(\"Input cannot be None\")\n        if ' ' in s:\n            return split_on_whitespace(s)\n        elif ',' in s:\n            return split_on_comma(s)\n        else:\n            return count_odd_lowercase_letters(s)\n\n    return main_function(txt)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    from collections import Counter\n    count = Counter(lst)\n    \n    # Check for more than one duplicate\n    if any(value > 2 for value in count.values()):\n        return False\n    \n    # Check for ascending order\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))", "result": "passed", "passed": true}
{"task_id": "HumanEval/127", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef interval_intersection_length(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start <= intersection_end:\n        return intersection_end - intersection_start + 1\n    else:\n        return 0\n\ndef intersection(interval1, interval2):\n    length = interval_intersection_length(interval1, interval2)\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    def sign(x):\n        if x > 0:\n            return 1\n        elif x < 0:\n            return -1\n        else:\n            return 0\n    \n    def product_of_signs(arr):\n        product = 1\n        for num in arr:\n            product *= sign(num)\n            if product == 0:\n                return 0\n        return product\n    \n    def sum_of_magnitudes(arr):\n        return sum(abs(num) for num in arr)\n    \n    product_sign = product_of_signs(arr)\n    if product_sign == 0:\n        return 0\n    \n    return sum_of_magnitudes(arr) * product_sign", "result": "passed", "passed": true}
{"task_id": "HumanEval/129", "completion": "from heapq import heappop, heappush\n\ndef neighbors(x, y, n):\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n:\n            yield nx, ny\n\ndef minPath(grid, k):\n    if k <= 0:\n        return []\n    \n    n = len(grid)\n    min_heap = [(grid[i][j], i, j, [grid[i][j]]) for i in range(n) for j in range(n)]\n    visited = set()\n    \n    while min_heap:\n        val, x, y, path = heappop(min_heap)\n        if len(path) == k:\n            return path\n        for nx, ny in neighbors(x, y, n):\n            if (nx, ny, len(path) + 1) not in visited:\n                visited.add((nx, ny, len(path) + 1))\n                heappush(min_heap, (grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n\n    return []", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    def tribonacci_value(k):\n        if k == 1:\n            return 3\n        elif k % 2 == 0:\n            return 1 + k / 2\n        else:\n            return tribonacci_value(k - 1) + tribonacci_value(k - 2) + tribonacci_value(k + 1)\n\n    def tribonacci_sequence(n):\n        return [tribonacci_value(i) for i in range(n + 1)]\n\n    return tribonacci_sequence(n)", "result": "passed", "passed": true}
{"task_id": "HumanEval/131", "completion": "def is_odd(digit):\n    return digit % 2 != 0\n\ndef product_of_odds(digits):\n    product = 1\n    has_odd = False\n    for digit in digits:\n        if is_odd(digit):\n            product *= digit\n            has_odd = True\n    return product if has_odd else 0\n\ndef digits(n):\n    if n is None or not isinstance(n, int) or n < 0:\n        return 0\n    digit_list = [int(d) for d in str(n)]\n    return product_of_odds(digit_list)", "result": "passed", "passed": true}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    stack = []\n    nested = False\n\n    for i, char in enumerate(string):\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n            if stack:\n                nested = True\n\n    return not stack and nested", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/133", "completion": "import math\n\ndef ceil_and_square(num):\n    return math.ceil(num) ** 2\n\ndef sum_squares(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    if any(isinstance(i, list) for i in lst):\n        raise ValueError(\"Nested lists are not allowed\")\n    if any(not isinstance(num, (int, float)) for num in lst):\n        raise ValueError(\"All elements in the list must be integers or floats\")\n    return sum(ceil_and_square(num) for num in lst)\n\n# Example usage:\n# result = sum_squares([1.4, 4.2, 0])\n# print(result)  # Output should be 16 + 25 + 0 = 41", "result": "passed", "passed": true}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    txt = txt.rstrip()\n    if not txt:\n        return False\n    last_char = txt[-1]\n    prev_char = txt[-2] if len(txt) > 1 else ' '\n    return last_char.isalpha() and (prev_char == ' ' or not prev_char.isalpha())", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    def find_largest_index(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return i\n        return -1\n\n    return find_largest_index(arr)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    def largest_negative_integer(lst):\n        negatives = [x for x in lst if isinstance(x, int) and x < 0]\n        return max(negatives, default=None)\n\n    def smallest_positive_integer(lst):\n        positives = [x for x in lst if isinstance(x, int) and x > 0]\n        return min(positives, default=None)\n\n    largest_negative = largest_negative_integer(lst)\n    smallest_positive = smallest_positive_integer(lst)\n\n    return (largest_negative, smallest_positive)", "result": "passed", "passed": true}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    def convert_to_float(value):\n        if value is None or value == \"\":\n            return None\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                raise TypeError(f\"Cannot convert {value} to float\")\n        try:\n            return float(value)\n        except ValueError:\n            raise TypeError(f\"Cannot convert {value} to float\")\n    \n    def compare_values(a, b):\n        try:\n            float_a = convert_to_float(a)\n            float_b = convert_to_float(b)\n        except TypeError:\n            return None\n        \n        if float_a is None and float_b is None:\n            return None\n        if float_a is None:\n            return b\n        if float_b is None:\n            return a\n        if float_a > float_b:\n            return a\n        elif float_b > float_a:\n            return b\n        else:\n            return None\n    \n    return compare_values(a, b)", "result": "passed", "passed": true}
{"task_id": "HumanEval/138", "completion": "def is_even(n):\n    return isinstance(n, int) and n % 2 == 0\n\ndef is_sum_of_four_evens(n):\n    return is_even(n) and n >= 8\n\ndef is_equal_to_sum_even(n):\n    return is_sum_of_four_evens(n) and isinstance(n, int) and n >= 8", "result": "passed", "passed": true}
{"task_id": "HumanEval/139", "completion": "import math\n\ndef brazilian_factorial(n):\n    if not isinstance(n, int) or n <= 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result\n\ndef special_factorial(n):\n    if not isinstance(n, int) or n <= 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/140", "completion": "import re\n\ndef replace_consecutive_spaces(text):\n    return re.sub(r' {3,}', '-', text)\n\ndef replace_single_spaces(text):\n    return text.replace(' ', '_')\n\ndef fix_spaces(text):\n    if text is None:\n        return \"\"\n    text = replace_consecutive_spaces(text)\n    text = re.sub(r'(?<!_) (?!_)', '_', text)\n    text = re.sub(r'_+', '_', text)\n    text = re.sub(r'\\s', '_', text)\n    return text", "result": "failed: This prints if this assert fails 3 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/141", "completion": "import re\n\ndef has_valid_digits(file_name):\n    return len(re.findall(r'\\d', file_name)) <= 3\n\ndef has_one_dot(file_name):\n    return file_name.count('.') == 1\n\ndef starts_with_letter(substring):\n    return substring and substring[0].isalpha()\n\ndef valid_extension(extension):\n    return extension in ['txt', 'exe', 'dll']\n\ndef file_name_check(file_name):\n    if not file_name:\n        return 'No'\n    \n    if not has_valid_digits(file_name):\n        return 'No'\n    \n    if not has_one_dot(file_name):\n        return 'No'\n    \n    name, ext = file_name.rsplit('.', 1)\n    \n    if not starts_with_letter(name):\n        return 'No'\n    \n    if not valid_extension(ext.lower()):\n        return 'No'\n    \n    return 'Yes'", "result": "passed", "passed": true}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    def process_entry(index, value):\n        if index % 3 == 0:\n            return value ** 2\n        elif index % 4 == 0:\n            return value ** 3\n        else:\n            return value\n    \n    def sum_processed_entries(lst):\n        return sum(process_entry(i, v) for i, v in enumerate(lst))\n    \n    return sum_processed_entries(lst)", "result": "passed", "passed": true}
{"task_id": "HumanEval/143", "completion": "def is_prime(n):\n    if not isinstance(n, int):\n        return False\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_with_prime_length(words):\n    return [word for word in words if is_prime(len(word))]\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = words_with_prime_length(words)\n    return ' '.join(prime_length_words)", "result": "passed", "passed": true}
{"task_id": "HumanEval/144", "completion": "from math import gcd\n\ndef parse_fraction(fraction):\n    numerator, denominator = map(int, fraction.split('/'))\n    return numerator, denominator\n\ndef multiply_fractions(frac1, frac2):\n    num1, den1 = parse_fraction(frac1)\n    num2, den2 = parse_fraction(frac2)\n    return num1 * num2, den1 * den2\n\ndef is_whole_number(numerator, denominator):\n    return numerator % denominator == 0\n\ndef simplify(frac1, frac2):\n    num, den = multiply_fractions(frac1, frac2)\n    return is_whole_number(num, den)\n\n# Example usage\nprint(simplify(\"1/5\", \"5/1\"))  # True\nprint(simplify(\"1/6\", \"2/1\"))  # False\nprint(simplify(\"7/10\", \"10/2\"))  # False\nprint(simplify(\"0/1\", \"1/1\"))  # True\nprint(simplify(\"1/1\", \"1/1\"))  # True\nprint(simplify(\"1/3\", \"3/1\"))  # True\nprint(simplify(\"2/4\", \"4/2\"))  # True\nprint(simplify(\"3/4\", \"4/3\"))  # True\nprint(simplify(\"1/7\", \"7/1\"))  # True\nprint(simplify(\"5/8\", \"8/5\"))  # True\nprint(simplify(\"3/7\", \"2/5\"))  # False\nprint(simplify(\"1/2\", \"2/3\"))  # False\nprint(simplify(\"1/1000000\", \"1000000/1\"))  # True\nprint(simplify(\"123/456\", \"789/123\"))  # False", "result": "passed", "passed": true}
{"task_id": "HumanEval/145", "completion": "def digit_sum(n):\n    return sum(int(digit) for digit in str(abs(n)))\n\ndef order_by_points(nums):\n    if not all(isinstance(x, int) for x in nums):\n        raise TypeError(\"All elements must be integers\")\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    def is_odd_digit(digit):\n        return digit in {1, 3, 5, 7, 9}\n\n    def first_digit(n):\n        n = abs(n)\n        while n >= 10:\n            n //= 10\n        return n\n\n    def last_digit(n):\n        return abs(n) % 10\n\n    def is_special(num):\n        if abs(num) <= 10:\n            return False\n        return is_odd_digit(first_digit(num)) and is_odd_digit(last_digit(num))\n\n    return sum(1 for num in nums if is_special(num))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    def generate_array(n):\n        return [i * i - i + 1 for i in range(1, n + 1)]\n\n    def count_triples(arr):\n        mod_count = [0, 0, 0]\n        for num in arr:\n            mod_count[num % 3] += 1\n        \n        # Calculate the number of valid triples\n        count = 0\n        count += mod_count[0] * (mod_count[0] - 1) * (mod_count[0] - 2) // 6  # (0, 0, 0)\n        count += mod_count[1] * (mod_count[1] - 1) * (mod_count[1] - 2) // 6  # (1, 1, 1)\n        count += mod_count[2] * (mod_count[2] - 1) * (mod_count[2] - 2) // 6  # (2, 2, 2)\n        count += mod_count[0] * mod_count[1] * mod_count[2]  # (0, 1, 2)\n        \n        return count\n\n    array = generate_array(n)\n    return count_triples(array)", "result": "passed", "passed": true}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    def validate_planet(planet):\n        return planet in planets\n    \n    def get_planet_index(planet):\n        return planets.index(planet)\n    \n    def get_planets_between(index1, index2):\n        if index1 < index2:\n            result = planets[index1 + 1:index2]\n        else:\n            result = planets[index2 + 1:index1]\n        return result[0] if len(result) == 1 else tuple(result)\n    \n    if not (validate_planet(planet1) and validate_planet(planet2)):\n        return ()\n    \n    index1 = get_planet_index(planet1)\n    index2 = get_planet_index(planet2)\n    \n    return get_planets_between(index1, index2)", "result": "failed: Second test error: Venus", "passed": false}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    def is_even_length(s):\n        return len(s) % 2 == 0\n\n    def sort_by_length_and_alpha(lst):\n        return sorted(lst, key=lambda x: (len(x), x))\n\n    def filter_even_length_strings(lst):\n        return [s for s in lst if is_even_length(s)]\n\n    filtered_lst = filter_even_length_strings(lst)\n    sorted_lst = sort_by_length_and_alpha(filtered_lst)\n    return sorted_lst", "result": "passed", "passed": true}
{"task_id": "HumanEval/150", "completion": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef x_or_y(n, x, y):\n    if isinstance(n, tuple):\n        n = n[0]\n    if is_prime(n):\n        return x\n    else:\n        return y", "result": "passed", "passed": true}
{"task_id": "HumanEval/151", "completion": "def is_valid_number(num):\n    return isinstance(num, int) and num >= 0\n\ndef is_odd(num):\n    return num % 2 != 0\n\ndef square(num):\n    return num * num\n\ndef double_the_difference(lst):\n    valid_numbers = filter(is_valid_number, lst)\n    odd_numbers = filter(is_odd, valid_numbers)\n    squared_numbers = map(square, odd_numbers)\n    return sum(squared_numbers)\n\n# Test cases\nprint(double_the_difference([1, 2, 3]))  # Expected: 10\nprint(double_the_difference([]))  # Expected: 0\nprint(double_the_difference([-1, -2, 0]))  # Expected: 0\nprint(double_the_difference([9, -2]))  # Expected: 81\nprint(double_the_difference([0]))  # Expected: 0\nprint(double_the_difference([1, 3, 5, 7, 9]))  # Expected: 165\nprint(double_the_difference([2, 4, 6, 8, 10]))  # Expected: 0\nprint(double_the_difference([1.5, 3.6, 2.1]))  # Expected: 0\nprint(double_the_difference([1, -3, 5, -7, 9]))  # Expected: 107\nprint(double_the_difference([1, 'a', 3, None, 5]))  # Expected: 35", "result": "passed", "passed": true}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    if len(game) != len(guess):\n        raise ValueError(\"Both lists must have the same length\")\n    \n    def calculate_difference(score, guess_value):\n        if not isinstance(score, (int, float)) or not isinstance(guess_value, (int, float)):\n            raise TypeError(\"Both score and guess must be numbers\")\n        return abs(score - guess_value)\n    \n    return [calculate_difference(game[i], guess[i]) for i in range(len(game))]", "result": "passed", "passed": true}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    if not extensions:\n        return f\"{class_name}.\"\n\n    def calculate_strength(extension):\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        return cap - sm\n\n    def find_strongest_extension(extensions):\n        strongest_extension = None\n        max_strength = float('-inf')\n        for ext in extensions:\n            strength = calculate_strength(ext)\n            if strength > max_strength:\n                strongest_extension = ext\n                max_strength = strength\n            elif strength == max_strength and extensions.index(ext) < extensions.index(strongest_extension):\n                strongest_extension = ext\n        return strongest_extension\n\n    strongest_extension = find_strongest_extension(extensions)\n    return f\"{class_name}.{strongest_extension}\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    if a is None or b is None:\n        return False\n    if b == \"\":\n        return True\n    for i in range(len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    if not isinstance(num, int):\n        raise ValueError(\"Input must be an integer\")\n\n    def is_even(digit):\n        return digit % 2 == 0\n\n    def count_digits(num):\n        even_count = 0\n        odd_count = 0\n        for digit in str(abs(num)):\n            if digit.isdigit():\n                if is_even(int(digit)):\n                    even_count += 1\n                else:\n                    odd_count += 1\n        return even_count, odd_count\n\n    return count_digits(num)", "result": "passed", "passed": true}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    if not isinstance(number, int) or number <= 0 or number > 1000:\n        return None\n\n    def get_roman_mapping():\n        return [\n            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n            (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n        ]\n\n    def convert_to_roman(num):\n        roman_mapping = get_roman_mapping()\n        roman_numeral = ''\n        for value, symbol in roman_mapping:\n            while num >= value:\n                roman_numeral += symbol\n                num -= value\n        return roman_numeral\n\n    roman_numeral = convert_to_roman(number)\n    return roman_numeral.lower()", "result": "passed", "passed": true}
{"task_id": "HumanEval/157", "completion": "def is_right_angle(a, b, c):\n    return a**2 + b**2 == c**2\n\ndef right_angle_triangle(a, b, c):\n    # Check for invalid inputs\n    if not all(isinstance(side, (int, float)) for side in [a, b, c]):\n        return False\n    if any(side <= 0 for side in [a, b, c]):\n        return False\n    sides = sorted([a, b, c])\n    return is_right_angle(sides[0], sides[1], sides[2])", "result": "passed", "passed": true}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    if not words:\n        return \"\"\n    \n    filtered_words = [word for word in words if word is not None]\n    if not filtered_words:\n        return \"\"\n    \n    def unique_char_count(word):\n        return len(set(word))\n    \n    max_word = max(filtered_words, key=lambda w: (unique_char_count(w), w), reverse=True)\n    return max_word", "result": "failed: max() got an unexpected keyword argument 'reverse'", "passed": false}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    if not all(isinstance(x, int) and x >= 0 for x in [number, need, remaining]):\n        raise ValueError(\"Inputs must be non-negative integers.\")\n    total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]", "result": "passed", "passed": true}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operators, operands):\n    import operator\n    import ast\n    import math\n\n    ops = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    if not operands or len(operators) >= len(operands):\n        raise ValueError(\"Invalid input: mismatched operators and operands\")\n\n    # Build the expression string\n    expression = str(operands[0])\n    for i in range(len(operators)):\n        expression += f\" {operators[i]} {operands[i + 1]}\"\n\n    # Parse the expression to handle operator precedence\n    try:\n        node = ast.parse(expression, mode='eval')\n        compiled_expr = compile(node, '<string>', 'eval')\n        result = eval(compiled_expr, {\"__builtins__\": None, 'operator': operator, 'math': math})\n    except ZeroDivisionError:\n        raise ZeroDivisionError(\"division by zero\")\n    except Exception as e:\n        raise ValueError(f\"Invalid expression: {e}\")\n\n    return result\n\n# Example usage:\n# operators = ['+', '*', '-']\n# operands = [2, 3, 4, 5]\n# print(do_algebra(operators, operands))  # Output: 9", "result": "passed", "passed": true}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    def reverse_case(c):\n        return c.upper() if c.islower() else c.lower()\n    \n    def has_letters(s):\n        return any(c.isalpha() for c in s)\n    \n    if has_letters(s):\n        return ''.join(reverse_case(c) if c.isalpha() else c for c in s)\n    else:\n        return s[::-1]", "result": "passed", "passed": true}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\ndef string_to_md5(text):\n    if text is None:\n        raise TypeError(\"Input cannot be None\")\n    if text == '':\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()", "result": "passed", "passed": true}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both arguments must be integers.\")\n    \n    def is_even(n):\n        return n % 2 == 0\n    \n    def get_even_digits(start, end):\n        return [i for i in range(start, end + 1) if is_even(i) and 0 <= i < 10]\n    \n    start, end = min(a, b), max(a, b)\n    return get_even_digits(start, end)", "result": "passed", "passed": true}
